\chapter{Исследовательский раздел}

В данном разделе будут приведены примеры работы программ, постановка эксперимента и сравнительный анализ алгоритмов на основе полученных данных.


\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялись замеры по времени, представлены далее.

\begin{enumerate}
	\item Процессор	Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz, 2592 МГц, ядер: 6, логических процессоров: 12;
	\item Оперативная память: 16 ГБайт;
	\item Операционная система: Майкрософт Windows 10 Pro \cite{windows};
	\item Использованная подсистема: WSL2 \cite{WSL2}.
\end{enumerate}

При замерах времени ноутбук был включен в сеть электропитания и был нагружен только системными приложениями.


\section{Временные характеристики}

Результаты исследования замеров по времени приведены в таблице \ref{t:timings}.
Введем следующие обозначения для чтения таблиц:
\begin{enumerate}
	\item n --- размерность умножаемых матриц;
	\item CМ --- реализация стандартного алгоритма умножения матриц;
	\item ВМ --- реализация алгоритма умножения матриц Винограда;
	\item ВМО ---реализация алгоритма умножения матриц Винограда (оптимизированный);
	\item ШМ --- реализация алгоритма умножения матриц Штрассена.
\end{enumerate}


\begin{table}[!ht]
	\centering
	\caption{Полученная таблица замеров по времени различных реализаций алгоритмов умножения матриц}
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		n   & СМ (мс)  & ШМ (мс)  & \multicolumn{1}{c|}{ВМ (мс)} & ВМО (мс) \\ \hline
		1   & 0.002159 & 0.004304 & 0.001817                     & 0.001758 \\ \hline
		11  & 0.025625 & 7.3367   & 0.023301                     & 0.020161 \\ \hline
		21  & 0.14005  & 46.559   & 0.11752                      & 0.1004   \\ \hline
		31  & 0.43789  & 46.262   & 0.34888                      & 0.29771  \\ \hline
		41  & 0.99899  & 326.63   & 0.78522                      & 0.66993  \\ \hline
		51  & 1.9746   & 332.43   & 1.5321                       & 1.3118   \\ \hline
		61  & 3.3842   & 329.97   & 2.5529                       & 2.1928   \\ \hline
		71  & 5.1593   & 2312.2   & 4.0072                       & 3.4496   \\ \hline
		81  & 7.5757   & 2279.9   & 5.763                        & 4.9773   \\ \hline
		91  & 10.703   & 2290.7   & 7.9208                       & 6.878    \\ \hline
		101 & 14.504   & 2300.3   & 11.025                       & 9.4659   \\ \hline
		111 & 19.166   & 2285.8   & 14.579                       & 12.439   \\ \hline
		121 & 25.184   & 2287.3   & 18.741                       & 16.192   \\ \hline
	\end{tabular}
	\label{t:timings}
\end{table}



\includeimage
{all-matrix-cmp} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Сравнение исследуемых алгоритмов по временри исполнения с использованием логарифмической шкалы} % Подпись рисунка

\includeimage
{vins-matrix-cmp} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Сравнение различных версий реализаций алгоритма Винограда} % Подпись рисунка

\includeimage
{std-vin-matrix-cmp} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Сравнение реализаций алгоритма Винограда и классического алгоритма умножения матриц} % Подпись рисунка







\section{Характеристики по памяти}

\label{memory}

Введем следующие обозначения:
\begin{itemize}
	\item $size()$ --- функция, вычисляющая размер в байтах;
	\item $int$ --- целочисленный тип данных;
	\item $int*$ --- указатель на тип $int$;
	\item $string$ --- строковый тип данных.
\end{itemize}

Рассмотрим объем памяти, занимаемой матрицей размерностью $n \times m$, расчет представлен в формуле (\ref{eq:mem_matrix}).
\begin{equation}
	\label{eq:mem_matrix}
	MEM_{m} = n \cdot m \cdot size(int) + 2 \cdot size(int) +  n \cdot size(int*).
\end{equation}

В случае классического алгоритма умножения матриц необходимо хранить только сами матрицы.В выражении (\ref{eq:mem_def}) операнды означают соответственно:
\begin{enumerate}
	\item $MEM_{m}(M1),MEM_{matrix}(M2)$ --- память входных матриц;
	\item $MEM_{m}(M3)$ --- память итоговой матрицы;
	\item $size(int)$ --- хранение кода возврата.
\end{enumerate}

\begin{equation}
	\label{eq:mem_def}
	MEM_{std} = MEM_{m}(M1) + MEM_{m}(M2) + MEM_{m}(M3) + size(int).
\end{equation}

Использование памяти при итеративной реализации теоритически рассчитывется по формул \eqref{eq:iter_mem}.
\begin{equation}
	\label{eq:iter_mem}
	(n + 1) * (m + 1) * size(int) + 2 * size(string) + 2 * size(int),
\end{equation}
где 
\begin{itemize}
	\item $ (n + 1) * (m + 1) * size(int) $ -- хранение матрицы;
	\item $ 2 * size(string) $ -- хранение двух строк;
	\item $ 2 * size(int) $ -- адрес возврата и возвращаемое значение.
\end{itemize}


Максимальная глубина стека вызовов при рекурсивной реализации
нахождения расстояния Дамерау---Левенштейна равна сумме входящих строк,
соответственно, максимальный расход памяти рассчитывается по \eqref{eq:rec_mem}.

\begin{equation}
	\label{eq:rec_mem}
	(n + m) * (2 * size(string) + 3 * size(int)),
\end{equation}
где 
\begin{itemize}
	\item $ (n + m) $ -- максимальная глубина стека вызовов;
	\item $ 2 * size(string) $ -- хранение двух строк;
	\item $ 2 * size(int) $ -- адрес возврата и возвращаемое значение;
	\item $ size(int) $ -- временная переменная.
\end{itemize}

Для алгоритма, использующего кеширование требуется дополнительно память под кеш и 4 временных переменных \eqref{eq:req_cash_mem}.

\begin{equation}
	\label{eq:req_cash_mem}
	(n + m) * (2 * size(string) + 6 * size(int)) + (n + 1) * (m + 1) * size(int),
\end{equation}
где 
\begin{itemize}
	\item $ (n + m) $ -- максимальная глубина стека вызовов;
	\item $ 2 * size(string) $ -- хранение двух строк;
	\item $ 2 * size(int) $ -- адрес возврата и возвращаемое значение;
	\item $ 4 * size(int) $ -- временные переменные;
	\item $ (n + 1) * (m + 1) * size(int) $ -- хранение кеша.
\end{itemize}

По расходу памяти итеративные алгоритмы проигрывают рекурсивным: максимальный размер используемой памяти в итеративном растет
как произведение длин строк, в то время как у рекурсивного алгоритма --
как сумма длин строк.


\section*{Вывод}

В данном разделе было произведено сравнение количества затраченного времени и памяти алгоритмов поиска расстояний Левенштейна и
Дамерау---Левенштейна. Наименее затратным по времени оказался итеративный алгоритм нахождения расстояния Левенштейна.

По таблице \ref{tbl:time_measurements} видно, что рекурсивный алгоритм в 65577 раз проигрывает итеративному при длине строк 10. Поэтому рекурсивные алгоритмы следует использовать лишь при малых длинах строк.

При этом как было замечено в пункте \ref{memory}, рекурсивные алгоритмы занимают меньше памяти, чем итеративные алгоритмы.

Рекурсивная реализация алгоритма поиска расстояния Дамерау---Левенштейн будет более затратным по времени по сравнению с итеративной реализацией алгоритма поиска расстояния Дамерау---Левенштейна, но менее затратным по памяти по отношению к итеративному алгоритму Дамерау---Левенштейна. При этом рекурсивные алгоритм с кешированием проигрывает по памяти и по времени итеративному.