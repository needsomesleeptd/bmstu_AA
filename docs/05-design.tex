\chapter{Конструкторский раздел}



В этом разделе будут рассмотрены различные реализации классического алгоритма умножения матриц и алгоритм умножения матриц
Винограда, а также алгоритм умножения матриц Штрассена.


\section{Реализации алгоритмов}

В данной части работы будут рассмотрены различные реализации алгоритмов
умножения матриц и представлены схемы алгоритмов данных реализаций.

На вход алгоритмов подаются матрицы $m_{1}$ и $m_{2}$ с размерностями $n_{1}\times m_{1}$ и $n_{2}\times m_{2}$.



\includeimage
{std} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Стандартный алгоритм расчета произведения матриц} % Подпись рисунка

\includeimage
{vin} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Алгоритм Винограда} % Подпись рисунка

\includeimage
{strassen} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Алгоритм Штрассена} % Подпись рисунка

\includeimage
{vin-opt} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Оптимизированный алгоритм Винограда} % Подпись рисунка




\section{Оценка трудоемкости реализаций алгоритмов}

Для последующего вычисления трудоемкости необходимо ввести модель вычислений.

\begin{enumerate}
	
	\item Трудоемкость следующих базовых операций единична:
	+, -, =, +=, -=, ==, !=, <, >, <=, >=, [], ++, --, <<, >>.
	
	Операции *, \%, / имеют трудоемкость 2;
	
	\item трудоемкость цикла \texttt{for(k = 0; k < N; k++)} \{тело цикла\} рассчитывается как:
	\begin{equation}
		\label{for:for}
		f_{for} = f_{\text{инициал.}} + f_{\text{сравн.}} + N(f_{\text{тела}} + f_{\text{инкр.}} + f_{\text{сравн.}});
	\end{equation}
	
	\item трудоемкость передачи параметра в функции и возврат из функции равны 0;
	\item трудоемкость условного оператора \texttt{if (условие) then A else B} рассчитывается как:
	
	\begin{equation}
		\label{for:if}
		f_{if} = f_{\text{условия}} +
		\begin{cases}
			min(f_A, f_B), & \text{л.с.}\\
			max(f_A, f_B), & \text{х.с.}
		\end{cases}
	\end{equation}
	
\end{enumerate}

В (\ref{for:if}), л.с. обозначает лучший случай, х.с. - худший случай.

\subsection{Трудоемкость реализации классического умножения матриц}

Для реализации \ref{lst:std} алгоритма умножения матриц трудоемкость будет слагаться из:
\begin{enumerate}
	\item Внешнего цикла по переменной $i$, имеющим трудоемкость $f_{for_i} = 1 + 1 + n_{1}\cdot(f_{for_j} + 1 + 1)$
	\item Внутреннего цикла по переменной $j$, имеющим трудоемкость $f_{for_j} = 1 + 1 + m_{2} \cdot(3 + f_{for_k}+ 1 +1)$
	\item Цикла по переменной $k$, имеющим трудоемкость $f_{for_k} = 1 + 1 + n_{2} \cdot(12  + 1 + 1)$
\end{enumerate}

Таким образом трудоемкость реализации стандартного алгоритма \ref{lst:std} вычисляется по формуле (\ref{сomp:std}).

\begin{equation}
	\label{сomp:std}
	\begin{gathered}
		f_{std} = 2 + n_{1} \cdot (2 + 2 + m_{2} \cdot (5 + 2 + n_{2} \cdot (12 +1 + 1)))= \\
		= 2 + 4n_{1} + 7n_{1}m_{2} + 14n_{1}m_{2}n_{2}
	\end{gathered}
\end{equation}

\subsection{Трудоемкость реализации алгоритма Винограда}
Для реализации \ref{lst:vin} алгоритма умножения матриц трудоемкость будет слагаться из:
\begin{enumerate}
	\item Цикла заполнения массива, хранящего информацию о произведениях строк (\ref{eq:f1_v});
	\item цикла заполнения массива, хранящего информацию о произведениях столбцов (\ref{eq:f2_v});
	\item цикла перемножения матриц (\ref{eq:f3_v});
	\item цикла дополнительных при расчетов при нечетных $m_{1},n_{2}$.
\end{enumerate}

\begin{equation}
	\label{eq:f1_v}
	f_{1}=2+n_{1}(1+3+\frac{m_{1}}{2}\cdot19)=\frac{19}{2}m_{1}n_{1}+4n_{1}+2,
\end{equation}

\begin{equation}
	\label{eq:f2_v}
	f_{2}=2+m_{2}(1 + 3+\frac{m_{1}}{2}\cdot19)=\frac{19}{2}m_{1}m_{2}+4m_{2}+2,
\end{equation}

\begin{equation}
	\begin{split}
	f_{3} = 2 + n_{1} \cdot (4 + m_{2} \cdot (2 + 7 + 4 + \frac{m_{1}}{2} \cdot (4 + 28))) = 2 + \\
	+4n_{1} + 13n_{1}m_{2} + 16n_{1}m_{1}m_{2},
	\end{split}
	\label{eq:f3_v}
\end{equation}

\begin{equation}
	\label{eq:f4_v}
	f4=3+
	\begin{cases}
		$$0$$, & \text{л.с.}\\
		$$2+n_{1}(4+(2 + 14)m_{2})=16n_{1}m_{2}+4n_{1}+2$$, & \text{х.с.}
	\end{cases}
\end{equation}

\subsection{Трудоемкость оптимизированной реализации алгоритма Винограда}
В данном случае используется несколько оптимизаций:
\begin{enumerate}
	\item Вместо операции умножения на 2 используется побитовый сдвиг влево, который имеет меньшую трудоемкость;
	\item кешируется значение$ \frac{m_{1}}{2}$;
	\item При сложении используется операция +=, имеющая меньшую трудоемкость.
\end{enumerate}

Трудоемкость реализации \ref{lst:vin_opt} слагается из циклов (\ref{eq:f1_v_opt} -- \ref{eq:f4_v_opt}) и трудоемкости кеширования:


\begin{equation}
	\label{eq:f1_v_opt}
	f_{1}=2+n_{1}(1+1+\frac{m_{1}}{2}\cdot13)=\frac{13}{2}m_{1}n_{1}+2n_{1}+2,
\end{equation}

\begin{equation}
	\label{eq:f2_v_opt}
	f_{2}=2+m_{2}(1 + 1+\frac{m_{1}}{2}\cdot13)=\frac{13}{2}m_{1}m_{2}+2m_{2}+2,
\end{equation}

\begin{equation}
	\begin{split}
	f_{3} = 2 + n_{1} \cdot (4 + m_{2} \cdot (2 + 7 + 2 + \frac{m_{1}}{2} \cdot (2 + 21))) = 2 + \\
	+ 4n_{1} + 11n_{1}m_{2} + \frac{23}{2}n_{1}m_{1}m_{2},
	\end{split}
	\label{eq:f3_v_opt}
\end{equation}
 
\begin{equation}
	\label{eq:f4_v_opt}
	f4=3+
	\begin{cases}
		$$0$$, & \text{л.с.}\\
		$$2+n_{1}(4+(2 + 13)m_{2})=15n_{1}m_{2}+4n_{1}+2$$, & \text{х.с.}
	\end{cases}
\end{equation}

Стоит учитывать  значение $\frac{m_{1}}{2}$, трудоемкость кеширования которого равно 3.


Наилучшим случаем для данных алгоритмов являются матрицы с четным числом столбцов в первой матрице и четным числом строк во втором.

\subsection{Трудоемкость реализации алгоритма Штрассена}
Реализация алгоритма штрассена \ref{lst:stras} рекурсивна, соответственно трудоемкость рекурсивной функции в общем случае будет вычислена по формуле:
\begin{equation}
	\label{for:rec}
	f_{rec} =
	\begin{cases}
		dir, & \text{ при $N = sizeLimit$}\\
		div(N) +\sum_{1}^{l}{rec(size[i])} + com(N), & \text{при $N> sizeLimit$}
	\end{cases}
\end{equation}
В формлуе (\ref{for:rec}), означают соответственно:
\begin{enumerate}
	\item dir --- трудоемкость нерекурсивного решения (база рекурсии);
	\item div --- трудоемкость разбиения задачи на подзадачи;
	\item rec --- трудоемкость решения подзадачи;
	\item com --- трудоемкость объеденения результатов решенных подзадач;
	\item N --- число входных элементов;
\end{enumerate}


В случае реализации алгоритма Штрассена:
\begin{enumerate}
	\item $dir  = 9$;
	\item $com =  2 + \frac{n}{2} \cdot (2 + 2 + \frac{n}{2} \cdot (2 +  (5 + 6 + 6 + 7))) = 2 +2n + \frac{13}{2}n^2$;
	\item $div$ В данном случае состоит из деления матриц на подматрицы.
	
	$div = 2 + \frac{n}{2} \cdot (2 + 2 + \frac{n}{2} \cdot (2 + 2 \cdot (5 + 6 + 6 + 7))) +10 \cdot mat_{op} = 4 + 22n + 30n^{2}$;

	\item $rec(n) = mat_{op} \cdot 18$,где $mat_{op} = 2 + \frac{n}{2} \cdot (2 + 2 + \frac{n}{2} \cdot (2 +5))$, операция сложения/вычитания матриц.
\end{enumerate}
Заметим, что в данной реализации матрицы - операнды дополняются до квадратных, порядок которых равен степени двойки. Так что наилучшим случаем будет квадратная матрица, порядок которой будет степень двойки.




\begin{equation}
	\label{for:rec_strassen_fixed}
	f_{rec} =
	\begin{cases}
		9, & \text{ при $N = 1$,}\\
		49n^2+26n+8 + \sum_{1}^{7}{rec(\frac{N}{2})}, & \text{при $N> 1$.}
	\end{cases}
\end{equation}

Таким образом трудоемкость рассчитывается по формуле  (\ref{for:rec_strassen_fixed}). Стоит отметить, что Штрассен в своей работе оптимизирует умножение только квадратных матриц с порядком кратным двум, поэтому в реализации \ref{lst:stras}, изначально матрицы приводятся к порядку, равному наименьшей степени двойки большей исходного порядка. Таким образом высота рекурсивного дерева будет равна $\log_{2}{N}$. При учете предыдущего условия трудоемкость алгоритма Щтрассена вычисляется по формуле (\ref{for:rec_strasseN_comp}).
\begin{equation}
	\label{for:rec_strasseN_comp}
	T = 7^{\log_{2}{N}}\cdot 9+ \sum_{0}^{\log_{2}{N} - 1}{7^{i} \cdot (49(\frac{N}{2^i})^2 + 4(\frac{N}{2^i})+ 4)}
\end{equation}






\section{Структуры данных}

Для реализации алгоритмов, будут использованы следующие типы данных:
Для реализации выбранных алгоритмов были использованы следующие структуры данных:
\begin{enumerate}
	\item Матрица --- массив массивов типа \texttt{int};
	\item размерности матрицы --- целые значение типа \texttt{size\_t}.
\end{enumerate}





\section*{Вывод}

Были разработаны схемы алгоритмов, позволяющих с помощью различных подходов находить произведение матриц, также была дана оценка трудоемкости для рассмотренных алгоритмов, кроме того были рассмотрены структуры данных, необходимые при реализации данных алгоритмов.  


