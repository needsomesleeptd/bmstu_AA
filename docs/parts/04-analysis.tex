\chapter{Аналитическая часть}
В данной части работы будет описан  алгоритм сортировки слиянием , 
а также рассмотрено использование многопоточности при его реализации.

\section{Алгоритм сортировки слиянием}


\subsection{Описание алгоритма}
Алгоритм сортировки слиянием (англ. merge Sort) является эффективным и стабильным алгоритмом сортировки, который применяет принцип "разделяй и властвуй" для упорядочивания элементов в массиве.

Алгоритм состоит из нескольких этапов:
\begin{enumerate}
	\item Разделение ---  исходный массив разделяется на две равные (или почти равные) половины. Это делается путем нахождения середины массива и создания двух новых массивов, в которые будут скопированы элементы из левой и правой половин.
	
	\item Рекурсивная сортировка: Каждая половина массива рекурсивно сортируется с помощью алгоритма сортировки слиянием. Этот шаг повторяется до тех пор, пока размер каждой половины не станет равным 1.

	\item Слияние: Отсортированные половины массива объединяются в один отсортированный массив. Для этого создается новый массив, в который будут последовательно добавляться элементы из левой и правой половин. При добавлении элементов выбирается наименьший элемент из двух половин и добавляется в новый массив. Этот шаг повторяется до тех пор, пока все элементы не будут добавлены в новый массив.
\end{enumerate}
В результате выполнения этих шагов получается отсортированный массив, который содержит все элементы исходного массива.

\subsection{Сложность алгоритма}
Обозначим размер сортируемого массива как $n$. 
Алгоритм сортировки слиянием разделяет массив на две половины до тех пор, пока размер каждой  не станет равным 1. Это занимает $O(log(n))$ итераций.
На каждом шаге происходит слияние двух отсортированных половин, что занимает O(n) времени. Так как слияние происходит на каждом шаге, общее время слияния будет $O(n log(n))$.
Таким образом, общее время выполнения алгоритма сортировки слиянием составляет $O(n  \cdot log(n))$.

Алгоритм сортировки слиянием требует дополнительной памяти для хранения временных массивов при разделении и слиянии. Размер временных массивов равен размеру исходного массива \cite{merge}.


\subsection{Использование потоков}
В данной задаче возможно использование потоков на 2 этапе алгоритма. Возможно <<выделение>> потока на каждый шаг рекурсии, в таком случае, 
отдельный поток будет рекурсивно сортировать отдельную часть массива  и затем выполнять ее слияние. Поток, запустивший следующий шаг рекурсии 
выделяет на каждую половину отдельный поток и ждет окончания их работы. Так как данные массива изменяются только на шаге слияния, а рекурсивная сортировка
разбивает массив на части и каждую часть обрабатывает отдельный поток в использовании средств синхронизации в виде мьютекса нет необходимости.

\section*{Вывод}
В данной части работы был описан алгоритм сортировки слиянием и рассмотрено использование многопоточности в его реализации.






