\chapter{Технологическая часть}
В данном разделе будут описаны средства реализации, модули программы, а также листинги, модульные и функциональные тесты
\section{Средства реализации}
Алгоритмы для данной лабораторной работы были реализованы на языке C++, при использовании компилятора gcc версии 10.5.0, так как в стандартной библиотеке приведенного языка
присутствует функция clock\_gettime, которая (при использовании макропеременной CLOCK\_THREAD\_CPUTIME\_ID) позволяет рассчитать процессорное время конкретного потока, 
что необходимо для решения четвертой из  поставленных задач (см. \ref{sec:targets}).\cite{cpp-time}.



\section{Листинги реализаций алгоритмов}

Стоит отметить, что все используемые выше алгоритмы реализованы как метода класса $Matrix$, ввиду того, что матрица
часто необходима для работы алгоритмов, в случае реализации алгоритма рекурсии без мемоизации (см. \ref{lst:damer_rec_meth}) матрица не нужна, однако 
алгоритм также является методом приведенного класса для валидного сравнения данного алгоритма с остальными.

\begin{lstlisting}[label=lst:lev_matr,caption=Метод нахождения расстояния Левенштейна с использованием матрицы]
    size_t Matrix::findMatrixDistLev(const std::wstring& st1, const std::wstring& st2)
    {
        int n = st1.size() + 1;
        int m = st2.size() + 1;
        if (n > _n || m > _m)
            assert(0);
        _table[0][0] = 0;
        for (int i = 1; i < n; i++)
            _table[i][0] = i;
        for (int j = 1; j < m; j++)
            _table[0][j] = j;
        for (int i = 1; i < n; i++)
        {
            for (int j = 1; j < m; j++)
            {
    
                _table[i][j] = std::min(_table[i][j - 1] + 1, _table[i - 1][j] + 1);
                int extraStep = 0;
                if (st1[i - 1] != st2[j - 1])
                    extraStep++;
                _table[i][j] = std::min(_table[i][j], _table[i - 1][j - 1] + extraStep);
            }
        }
        return _table[n - 1][m - 1];
    }
\end{lstlisting}

\begin{lstlisting}[label=lst:damer_matr,caption=Метод нахождения расстояния Дамерау-Левенштейна с использованием матрицы]
    size_t Matrix::findMatrixDistDamerau(const std::wstring& st1, const std::wstring& st2)
    {
        int n = st1.size() + 1;
        int m = st2.size() + 1;
        if (n > _n || m > _m)
            assert(0);
        _table[0][0] = 0;
        for (int i = 1; i < n; i++)
            _table[i][0] = i;
        for (int j = 1; j < m; j++)
            _table[0][j] = j;
        for (int i = 1; i < n; i++)
        {
            for (int j = 1; j < m; j++)
            {
    
                _table[i][j] = std::min(_table[i][j - 1] + 1, _table[i - 1][j] + 1);
                int extraStep = 0;
                if (st1[i - 1] != st2[j - 1])
                    extraStep++;
    
                _table[i][j] = std::min(_table[i][j], _table[i - 1][j - 1] + extraStep);
                if (i > 1 && j > 1)
                {
                    if (st1[i - 1] == st2[j - 2] && st1[i - 2] == st2[j - 1])
                        _table[i][j] = std::min(_table[i][j], _table[i - 2][j - 2] + 1);
                }
            }
        }
        return _table[n - 1][m - 1];
    }
\end{lstlisting}

\begin{lstlisting}[label=lst:damer_rec,caption=Функция нахождения расстояния Дамерау-Левенштейна с использованием рекурсии]
    size_t RecurseDistDamerau(const std::wstring& st1, const std::wstring& st2, int size1, int size2)
    {
        if (size1 == 0)
            return size2;
        if (size2 == 0)
            return size1;
    
        size_t extraStep = 0;
        if (st1[size1 - 1] != st2[size2 - 1])
            extraStep++;
    
        size_t cutLeft = RecurseDistDamerau(st1, st2, size1 - 1, size2) + 1;
        size_t cutRight = RecurseDistDamerau(st1, st2, size1, size2 - 1) + 1;
        size_t cutBoth = RecurseDistDamerau(st1, st2, size1 - 1, size2 - 1) + extraStep;
        size_t DamerauCut = cutBoth + 1;
        if (size1 > 1 && size2 > 1 && st1[size1 - 1] == st2[size2 - 2]
            && st1[size1 - 2] == st2[size2 - 1])
            DamerauCut = RecurseDistDamerau(st1, st2, size1 - 2, size2 - 2) + 1;
    
        cutBoth = std::min(DamerauCut, cutBoth); //need static here
        size_t chosenOne = std::min(std::min(cutRight, cutLeft), cutBoth);
        return chosenOne;
    }
\end{lstlisting}

\begin{lstlisting}[label=lst:damer_rec_mem,caption=Функция нахождения расстояния Дамерау-Левенштейна с использованием рекурсии c мемоизацией]
    size_t RecurseDistMemDamerau(const std::wstring& st1,
	const std::wstring& st2,
	int lastIndex1,
	int lastIndex2,
	Matrix& mat)
    {
        //std::cout<< "i " << "j " << lastIndex1 << " " << lastIndex2 << std::endl;
        if (mat._table[lastIndex1][lastIndex2] != INF)
            return mat._table[lastIndex1][lastIndex2];

        if (lastIndex1 == 0)
        {
            mat._table[lastIndex1][lastIndex2] = lastIndex2;
            return lastIndex2;
        }
        if (lastIndex2 == 0)
        {
            mat._table[lastIndex1][lastIndex2] = lastIndex1;
            return lastIndex1;
        }



        int extraStep = 0;
        if (st1[lastIndex1 - 1] != st2[lastIndex2 - 1])
            extraStep++;

        int cutLeft = RecurseDistMemDamerau(st1, st2, lastIndex1 - 1, lastIndex2,mat) + 1;
        int cutRight = RecurseDistMemDamerau(st1, st2, lastIndex1, lastIndex2 - 1,mat) + 1;
        int cutBoth = RecurseDistMemDamerau(st1, st2, lastIndex1 - 1, lastIndex2 - 1,mat) + extraStep;
        int DamerauCut = cutBoth + 1;
        if (lastIndex1 > 1 && lastIndex2 > 1 && st1[lastIndex1 - 2] == st2[lastIndex2 - 1]
            && st1[lastIndex1 - 1] == st2[lastIndex2 - 2])
            DamerauCut = RecurseDistMemDamerau(st1, st2, lastIndex1 - 2, lastIndex2 - 2,mat) + 1;
        cutBoth = std::min(DamerauCut, cutBoth);
        int chosenOne = std::min(std::min(cutRight, cutLeft), cutBoth);
        mat._table[lastIndex1][lastIndex2] = chosenOne;
        return chosenOne;
    }
\end{lstlisting}

\begin{lstlisting}[label=lst:damer_rec_mem_meth, caption=Метод нахождения расстояния Дамерау-Левенштейна с использованием функции \ref{lst:damer_rec_mem}]
    const int INF = 1e8;
    size_t Matrix::findRecurseDistMemDamerau(const std::wstring& st1, const std::wstring& st2)
    {
        for (int i = 0; i < _n; i++)
            for (int j = 0; j < _m; j++)
                _table[i][j] = INF;
        
        return RecurseDistMemDamerau(st1, st2, st1.size(), st2.size(), *this);
    }
\end{lstlisting}

\begin{lstlisting}[label=lst:damer_rec_meth, caption=Метод нахождения расстояния Дамерау-Левенштейна с использованием функции \ref{lst:damer_rec}]
size_t Matrix::findRecurseDistDamerau(const std::wstring& st1, const std::wstring& st2)
{
	return RecurseDistDamerau(st1, st2, st1.size(), st2.size());
}
\end{lstlisting}

\section{Тестирование}
При написании тестов использовалась библиотека $gtest$, позволяющая писать модульные тесты, которые очень удобны 
в данном случае. Данные тесты приведены в листинге  \ref{lst:unit_tests}. При реализации данных тестов вычисленные значения
сравниваются со значениями, заранее известными для соответствующих входных данных, с помощью приведенной библиотеки.
\begin{lstlisting}[label=lst:unit_tests, caption=Модульные тесты]
   //
   // Created by Андрей on 10/09/2023.
   //
   #include <gtest/gtest.h>
   #include "../../src/table.hpp"
   
   //Тестирование при словах одинаковой длины
   TEST(LenTest, EQLENTEST) {
   	std::wstring st1 = L"wwwwwwc";
   	std::wstring st2 = L"bbbbbbc";
   	Matrix mat(st1.size(),st2.size());
   	
   	int DamerauLen = 6;
   	int LevLen  = 6;
   	
   	int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
   	int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
   	int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
   	
   	int lenMatLev = mat.findMatrixDistLev(st1,st2);
   	
   	ASSERT_EQ(DamerauLen,lenMatDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
   	ASSERT_EQ(LevLen,lenMatLev);
   }
   
   //Тестирование с различными результатами при использовании различных расстояний
   TEST(LenTest, DIFLENTEST) {
   	std::wstring st1 = L"AB";
   	std::wstring st2 = L"BA";
   	Matrix mat(st1.size(),st2.size());
   	
   	int DamerauLen = 1;
   	int LevLen  = 2;
   	
   	int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
   	int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
   	int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
   	
   	int lenMatLev = mat.findMatrixDistLev(st1,st2);
   	
   	ASSERT_EQ(DamerauLen,lenMatDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
   	ASSERT_EQ(LevLen,lenMatLev);
   }
   
   
   //Различающийся результат расстояний при словах различной длины
   TEST(LenTest, LongWords) {
   	std::wstring st1 = L"KAABKA";
   	std::wstring st2 = L"AKAAK";
   	Matrix mat(st1.size(),st2.size());
   	
   	int DamerauLen = 3;
   	int LevLen  = 3;
   	
   	int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
   	int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
   	int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
   	
   	int lenMatLev = mat.findMatrixDistLev(st1,st2);
   	
   	ASSERT_EQ(DamerauLen,lenMatDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
   	ASSERT_EQ(LevLen,lenMatLev);
   }
   
   //Тестирование подобное тесту на русском языке
   TEST(LenTest, English) {
   	std::wstring st1 = L"BCA";
   	std::wstring st2 = L"ABC";
   	Matrix mat(st1.size(),st2.size());
   	
   	int DamerauLen = 2;
   	int LevLen  = 2;
   	
   	int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
   	int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
   	int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
   	
   	int lenMatLev = mat.findMatrixDistLev(st1,st2);
   	
   	ASSERT_EQ(DamerauLen,lenMatDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
   	ASSERT_EQ(LevLen,lenMatLev);
   }
   
   //Использование русских букв
   TEST(LenTest, Russian) {
   	std::wstring st1 = L"ВФА";
   	std::wstring st2 = L"АВФ";
   	Matrix mat(st1.size(),st2.size());
   	
   	int DamerauLen = 2;
   	int LevLen  = 2;
   	
   	int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
   	int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
   	int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
   	
   	int lenMatLev = mat.findMatrixDistLev(st1,st2);
   	
   	ASSERT_EQ(DamerauLen,lenMatDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
   	ASSERT_EQ(LevLen,lenMatLev);
   }
   
   //Большая разница в длине слов
   TEST(LenTest, BIGSIZEDIFF) {
   	std::wstring st1 = L"ADF";
   	std::wstring st2 = L"ABFDSADADF";
   	Matrix mat(st1.size(),st2.size());
   	
   	int DamerauLen = 7;
   	int LevLen  = 7;
   	
   	int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
   	int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
   	int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
   	
   	int lenMatLev = mat.findMatrixDistLev(st1,st2);
   	
   	ASSERT_EQ(DamerauLen,lenMatDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseDamerau);
   	ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
   	ASSERT_EQ(LevLen,lenMatLev);
   }
\end{lstlisting}

Также данные тесты рассмотрены в таблице \ref{t:unit_tests}.

\begin{table}[ht]
	
	\begin{center}
		\small
		\begin{threeparttable}
		\caption{Модульные тесты}
        \label{t:unit_tests}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			\multicolumn{2}{|c|}{\bfseries Входные данные}
			& \multicolumn{4}{c|}{\bfseries Расстояние и алгоритм} \\ 
			\hline 
			&
			& \multicolumn{1}{c|}{\bfseries Левенштейна} 
			& \multicolumn{3}{c|}{\bfseries Дамерау-Левенштейна} \\ \cline{3-6}
			
			\bfseries Строка 1 & \bfseries Строка 2 & \bfseries Итеративный & \bfseries Итеративный
			
			& \multicolumn{2}{c|}{\bfseries Рекурсивный} \\ \cline{5-6}
			& & & & \bfseries Без кеша & \bfseries С кешом \\
			\hline
			wwwwwwc & bbbbbbc & 6 & 6 & 6 & 6 \\
			\hline
			AB & BA & 2 & 1 & 1 & 1 \\
			\hline
			KAABKA & AKAAK & 3 & 3 & 3 & 3 \\
			\hline
			ABC & BCA & 2 & 2 & 2 & 2 \\
			\hline
			ВФА & АВФ & 2 & 2 & 2 & 2 \\
			\hline
			ADF & ABFDSADADF & 7 & 7 & 7 & 7 \\
			\hline
		\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

Все тесты были успешно пройдены.