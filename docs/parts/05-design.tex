\chapter{Конструкторская часть}
В данной части работы будут рассмотрены схемы алгоритмов сортировок, а также приведен расчет их трудоемкости.





\section{Схемы алгоритмов}
На рисунках \ref{img:koktail}--\ref{img:radix} приведены схемы алгоритмов сортировки перемешиванием, блочной и поразрядной сортировки соответственно.

\includeimage
{koktail} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма сортировки перемешиванием} % Подпись рисунка



\includeimage
{block} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма блочной сортировки} % Подпись рисунка


\includeimage
{radix} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма поразрядной сортировки} % Подпись рисунка




\section{Оценка трудоемкости реализаций алгоритмов}
Для последующего вычисления трудоемкости необходимо ввести модель вычислений.

\begin{enumerate}
	
	\item Трудоемкость следующих базовых операций единична:
	+, -, =, +=, -=, ==, !=, <, >, <=, >=, [], ++, --, <<, >>.
	
	Операции *, \%, / имеют трудоемкость 2.
	
	\item Трудоемкость цикла \texttt{for(k = 0; k < N; k++)} \{тело цикла\} рассчитывается по формуле (\ref{for:for}).
	\begin{equation}
		\label{for:for}
		f_{for} = f_{\text{инициал.}} + f_{\text{сравн.}} + N(f_{\text{тела}} + f_{\text{инкр.}} + f_{\text{сравн.}}).
	\end{equation}
	
	\item Трудоемкость передачи параметра в функции и возврат из функции равны 0.
	\item Трудоемкость условного оператора \texttt{if (условие) then A else B} рассчитывается по формуле (\ref{for:if}), в данном случае л.с. обозначает лучший случай, х.с. - худший случай.
	
	\begin{equation}
		\label{for:if}
		f_{if} = f_{\text{условия}} +
		\begin{cases}
			min(f_A, f_B), & \text{л.с.}\\
			max(f_A, f_B), & \text{х.с.}
		\end{cases}
	\end{equation}
	
\end{enumerate}


В приведенных сортировках $n$ обозначает число элементов в последовательности.
\subsection{Трудоемкость реализации сортировки перемешиванием}
В данном случаях считается, что трудоемкость обмена элементов местами равна 5.

\textbf{Лучший случай:} последовательность уже отсортирована, ни одного захода в тело условного оператора не произошло, расчет трудоемкости данного случая приведен в формуле (\ref{сomplexity:shaker_best}).
\begin{equation}
	\label{сomplexity:shaker_best}
	\begin{gathered}
		f_{best} =\sum_{i=0}^{n}  (3 +  1 + 1 + i \cdot (1 +4  + 1) + 1 +1 +1 +1) =\\ =\sum_{i=0}^{n} (9 + 6 \cdot i) = \\
		= 15 \cdot n + \frac{n^2}{2} - \frac{n}{2}  = O(n^2).
	\end{gathered}
\end{equation}

\textbf{Худший случай:} последовательность отсортирована в обратном порядке (необходимо каждый раз заходить в тело условного оператора), приведен в формуле (\ref{сomplexity:shaker_worst}).

\begin{equation}
	\label{сomplexity:shaker_worst}
	\begin{gathered}
		f_{worst} = \sum_{i=0}^{n}  (3 +  1 + 1 + i \cdot (1 +4  + 1 + 5) + 1 +1 +1 +1 = \\ = \sum_{i=0}^{n} 9 + 11 \cdot i = \\
		= 20 \cdot n + \frac{n^2}{2} - \frac{n}{2} = O(n^2).
	\end{gathered}
\end{equation}


\textbf{Вывод о  трудоемкости сортировки перемешиванием}

Данная реализация зависит от выбранного размера блока, а также от количества сортируемых элементов. В соответствии с выражениями (\ref{сomplexity:shaker_worst}, \ref{сomplexity:shaker_best}), различие в трудоемкости лучшего и худшего случая проявляется в необходимости в необходимости обмена элементов местами в худшем случае.



\subsection{Трудоемкость реализации блочной сортировки}
В данной реализации размер блока обозначается как $k$, трудоемкость операции добавления и удаления элемента из вектора равна 2.


\textbf{Лучший случай:} массив отсортирован, элементы распределены равномерно (все блоки содержат одинаковое число элементов), расчет трудоемкости данного случая приведен в (\ref{сomplexity:block_best}).


\begin{equation}
	\label{сomplexity:block_best}
	\begin{gathered}
		f_{best} = 1 +1 + \frac{n}{k} \cdot(1 + 2+f_{shaker} + 2 + 1 + 4 + \\
		+ k \cdot (3 + 1 + 4)) + 1 + 1 + \\
		+ \frac{n}{k} \cdot (1 + 4 + 1 + 1 + 5 + 1 + 4 + 1 + 1 + n \cdot (5)) = \\
		= 4 + \frac{29\cdot n + n \cdot f_{shaker} + 5 \cdot n^2}{k}  + 8 \cdot n  = \\
		= 4 + 8 \cdot n + 29 \cdot \frac{n}{k} + n \cdot (14.5 + \frac{k}{2}) + \frac{5 \cdot n^2}{k}.
	\end{gathered}
\end{equation}




\textbf{Худший случай:} большое количество пустых блоков, массив отсортирован в обратном порядке (худший случай сортировки перемешиванием, которая используется в блочной сортировке), расчет трудоемкости приведен в выражении (\ref{сomplexity:block_worst}).

\begin{equation}
	\label{сomplexity:block_worst}
	\begin{gathered}
		f_{worst} = 1 +1 + \frac{n}{k} \cdot(1 + 2+f_{shaker} + 2 + 1 + 4 + \\
		+ k \cdot (3 + 1 + 4)) + 1 + 1 + \\
		 + \frac{n}{k} \cdot (1 + 4 + 1 + 1 + 5 + 1 + 4 + 1 + 1 + k \cdot (6)) = \\
		= 4 + \frac{29\cdot n + n \cdot f_{shaker} + 6 \cdot n^2}{k}  + 8 \cdot n  = \\
		= 4 + 8 \cdot n + 29 \cdot \frac{n}{k} + n \cdot (19.5 + \frac{k}{2}) + \frac{6 \cdot n^2}{k}.
	\end{gathered}
\end{equation}


\textbf{Вывод о  трудоемкости блочной сортировки}

Данная реализация зависит от выбранного размера блока, а также от количества сортируемых элементов. В соответствии с выражениями (\ref{сomplexity:block_worst} , \ref{сomplexity:block_best}) в случае выбора значения $k$, близкого к $n$, операнд $\frac{n^2}{k}$ уменьшится, при этом операнд $\frac{n \cdot k}{2}$  уменьшиться, в случае выбора иных значений $k$, $n$ приведенные ранее операнды будут влиять на значение  трудоемкости данной реализации сортировки.


\subsection{Трудоемкость реализации сортировки разрядов подсчетом}

Трудоемкость реализации разрядов подсчетом равна:
\begin{equation}
	\label{сomplexity:count_best_worst}
	\begin{gathered}
		f_{count} = 1 + 1 + 1 + n \cdot (2 + 7)	 + 1 + 1 + 20 \cdot (1 + 1 + 4) + \\
		+ 2 + 1 + n \cdot (1 + 1 + 10 + 7) + 1 + 1 + n \cdot(1 +1 + 3) = \\
		= 130 + 33 \cdot n.
	\end{gathered}
\end{equation}

Данная сортировка используется при реализации поразрядной сортировки, и не содержит условных операторов, соответственно не имеет лучшего и худшего случая





\subsection{Трудоемкость реализации поразрядной сортировки}
В данном случае за $w$ принимается количество разрядов максимально большого по модулю числа.

\textbf{Лучший случай:} наибольшее по модулю значение находится в начале массива, расчет трудоемкости данного случая приведен в (\ref{сomplexity:radix_best}).


\begin{equation}
	\label{сomplexity:radix_best}
	\begin{gathered}
		f_{best} = 1 + 1 + 1 + n \cdot (2 + 2) + 1 +3 + w \cdot (2 + 3 + f_{count}) = \\
		= 7 + 4 \cdot n + 135 \cdot w + 33 \cdot n \cdot w = O(n \cdot w).
	\end{gathered}
\end{equation}


\textbf{Худший случай:} изначально последовательность отсортирована по возрастанию модуля значений, расчет трудоемкости приведен в выражении (\ref{сomplexity:radix_worst}).

\begin{equation}
	\label{сomplexity:radix_worst}
	\begin{gathered}
		f_{best} = 1 + 1 + 1 + n \cdot (2 + 2 + 2) + 1 +3 + w \cdot (2 + 3 + f_{count}) = \\
		= 7 + 6 \cdot n + 135 \cdot w + 33 \cdot n \cdot w = O(n \cdot w).
	\end{gathered}
\end{equation}

\textbf{Вывод о  трудоемкости  реализации поразрядной сортировки}

Выражения (\ref{сomplexity:radix_worst}, \ref{сomplexity:radix_best}), иллюстрируют зависимость данной реализации от количества сортируемых элементов и от максимального числа разрядов в наибольшем по модулю числе.




\textbf{Вывод}

В данном разделе на основе теоретических данных были построены схемы
требуемых алгоритмов, а также для каждого алгоритма сортировки были выведены трудоемкости худшего и лучшего случаев.









