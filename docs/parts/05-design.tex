\chapter{Конструкторская часть}
В данной части работы будут рассмотрены схемы алгоритмов сортировок, а также приведен расчет их трудоемкости.





\section{Схемы алгоритмов}
\includeimage
{koktail} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма сортировки перемешиванием} % Подпись рисунка



\includeimage
{block} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма блочной сортировки} % Подпись рисунка


\includeimage
{radix} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма поразрядной сортировки} % Подпись рисунка




\section{Оценка трудоемкости реализаций алгоритмов}
Для последующего вычисления трудоемкости необходимо ввести модель вычислений.

\begin{enumerate}
	
	\item Трудоемкость следующих базовых операций единична:
	+, -, =, +=, -=, ==, !=, <, >, <=, >=, [], ++, --, <<, >>.
	
	Операции *, \%, / имеют трудоемкость 2;
	
	\item трудоемкость цикла \texttt{for(k = 0; k < N; k++)} \{тело цикла\} рассчитывается как:
	\begin{equation}
		\label{for:for}
		f_{for} = f_{\text{инициал.}} + f_{\text{сравн.}} + N(f_{\text{тела}} + f_{\text{инкр.}} + f_{\text{сравн.}});
	\end{equation}
	
	\item трудоемкость передачи параметра в функции и возврат из функции равны 0;
	\item трудоемкость условного оператора \texttt{if (условие) then A else B} рассчитывается как:
	
	\begin{equation}
		\label{for:if}
		f_{if} = f_{\text{условия}} +
		\begin{cases}
			min(f_A, f_B), & \text{л.с.}\\
			max(f_A, f_B), & \text{х.с.}
		\end{cases}
	\end{equation}
	
\end{enumerate}

В (\ref{for:if}), л.с. обозначает лучший случай, х.с. - худший случай.

В приведенных сортировках $n$ обозначает число элементов в последовательности.
\subsection{Трудоемкость реализации сортировки перемешиванием}
\textbf{Лучший случай:} последовательность уже отсортирована, не одного захода в тело условного оператора приведен в формуле (\ref{сomplexity:shaker_best}).

В данном случаях считается, что трудоемкость обмена элементов местами равна 5.
\begin{equation}
	\label{сomplexity:shaker_best}
	\begin{gathered}
		f_{best} =\sum_{i=0}^{n}  (3 +  1 + 1 + i \cdot (1 +4  + 1) + 1 +1 +1 +1) =\\ =\sum_{i=0}^{n} (9 + 6 \cdot i) = \\
		= 15 \cdot n + \frac{n^2}{2} - \frac{n}{2}  = O(n^2)
	\end{gathered}
\end{equation}

\textbf{Худший случай:} последовательность отсортирована в обратном порядке (необходимо каждый раз заходить в тело условного оператора), приведен в формуле (\ref{сomplexity:shaker_worst}).

\begin{equation}
	\label{сomplexity:shaker_worst}
	\begin{gathered}
		f_{worst} = \sum_{i=0}^{n}  (3 +  1 + 1 + i \cdot (1 +4  + 1 + 5) + 1 +1 +1 +1 = \\ = \sum_{i=0}^{n} 9 + 11 \cdot i = \\
		= 20 \cdot n + \frac{n^2}{2} - \frac{n}{2} = O(n^2)
	\end{gathered}
\end{equation}

\subsection{Трудоемкость реализации блочной сортировки}
В данной реализации размер блока обозначается как $k$, трудоемкость операции добавления и удаления элемента из вектора равна 2.


\textbf{Лучший случай:} массив отсортирован, элементы распределены равномерно (все блоки содержат одинаковое число элементов), расчет трудоемкости данного случая приведен в (\ref{сomplexity:block_best}).


\begin{equation}
	\label{сomplexity:block_best}
	\begin{gathered}
		f_{best} = 1 +1 + \frac{n}{k} \cdot(1 + 2+f_{shaker} + 2 + 1 + 4 + \\
		k \cdot (3 + 1 + 4)) + 1 + 1 + \\
		\frac{n}{k} \cdot (1 + 4 + 1 + 1 + 5 + 1 + 4 + 1 + 1 + n \cdot (5)) = \\
		= 4 + \frac{29\cdot n + n \cdot f_{shaker} + 5 \cdot n^2}{k}  + 8 \cdot n  = \\
		= 4 + 8 \cdot n + 29 \cdot \frac{n}{k} + n \cdot (14.5 + \frac{k}{2}) + \frac{5 \cdot n^2}{k} 
	\end{gathered}
\end{equation}




\textbf{Худший случай:} большое количество пустых блоков, массив отсортирован в обратном порядке (худший случай сортировки перемешиванием, которая используется в блочной сортировке), расчет трудоемкости приведен в выражении \ref{сomplexity:block_worst}.

\begin{equation}
	\label{сomplexity:block_worst}
	\begin{gathered}
		f_{worst} = 1 +1 + \frac{n}{k} \cdot(1 + 2+f_{shaker} + 2 + 1 + 4 + \\
		k \cdot (3 + 1 + 4)) + 1 + 1 + \\
		\frac{n}{k} \cdot (1 + 4 + 1 + 1 + 5 + 1 + 4 + 1 + 1 + k \cdot (6)) = \\
		= 4 + \frac{29\cdot n + n \cdot f_{shaker} + 6 \cdot n^2}{k}  + 8 \cdot n  = \\
		= 4 + 8 \cdot n + 29 \cdot \frac{n}{k} + n \cdot (19.5 + \frac{k}{2}) + \frac{6 \cdot n^2}{k} 
	\end{gathered}
\end{equation}

\subsection{Трудоемкость реализации сортировки разрядов подсчетом}

\begin{equation}
	\label{сomplexity:count_best_worst}
	\begin{gathered}
		f_{count} = 1 + 1 + 1 + n \cdot (2 + 7)	 + 1 + 1 + 20 \cdot (1 + 1 + 4) + \\
		+ 2 + 1 + n \cdot (1 + 1 + 10 + 7) + 1 + 1 + n \cdot(1 +1 + 3) = \\
		= 130 + 33 \cdot n
	\end{gathered}
\end{equation}

Данная сортировка используется при реализации поразрядной сортировки, и не содержит условных операторов, соответственно не имеет лучшего и худшего случая


\subsection{Трудоемкость реализации поразрядной сортировки}
В данном случае за $w$ принимается количество разрядов максимально большого по модулю числа.
\textbf{Лучший случай:} наибольшее по модулю значение находится в начале массива, расчет трудоемкости данного случая приведен в (\ref{сomplexity:radix_best}).


\begin{equation}
	\label{сomplexity:radix_best}
	\begin{gathered}
		f_{best} = 1 + 1 + 1 + n \cdot (2 + 2) + 1 +3 + w \cdot (2 + 3 + f_{count}) = \\
		= 7 + 4 \cdot n + 135 \cdot w + 33 \cdot n \cdot w = O(n \cdot w)
	\end{gathered}
\end{equation}


\textbf{Худший случай:} изначально последовательность отсортирована по возрастаю модуля значений, расчет трудоемкости приведен в выражении \ref{сomplexity:radix_worst}.

\begin{equation}
	\label{сomplexity:radix_worst}
	\begin{gathered}
		f_{best} = 1 + 1 + 1 + n \cdot (2 + 2 + 2) + 1 +3 + w \cdot (2 + 3 + f_{count}) = \\
		= 7 + 6 \cdot n + 135 \cdot w + 33 \cdot n \cdot w = O(n \cdot w)
	\end{gathered}
\end{equation}




\textbf{Вывод}

В данном разделе на основе теоретических данных были построены схемы
требуемых алгоритмов, а также для каждого алгоритма сортировки были выведены трудоемкости худшего и лучшего случаев.









