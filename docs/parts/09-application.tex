\chapter*{\hfill \centering ПРИЛОЖЕНИЕ А\hfill}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ А}
Приведены листинги реализаций расчета редакционных расстояний.

\begin{lstlisting}[label=lst:lev_matr,caption=Метод нахождения расстояния Левенштейна с использованием матрицы]
    size_t Matrix::findMatrixDistLev(const std::wstring& st1, const std::wstring& st2)
    {
        int n = st1.size() + 1;
        int m = st2.size() + 1;
        if (n > _n || m > _m)
            assert(0);
        _table[0][0] = 0;
        for (int i = 1; i < n; i++)
            _table[i][0] = i;
        for (int j = 1; j < m; j++)
            _table[0][j] = j;
        for (int i = 1; i < n; i++)
        {
            for (int j = 1; j < m; j++)
            {
    
                _table[i][j] = std::min(_table[i][j - 1] + 1, _table[i - 1][j] + 1);
                int extraStep = 0;
                if (st1[i - 1] != st2[j - 1])
                    extraStep++;
                _table[i][j] = std::min(_table[i][j], _table[i - 1][j - 1] + extraStep);
            }
        }
        return _table[n - 1][m - 1];
    }
\end{lstlisting}

\begin{lstlisting}[label=lst:damer_matr,caption=Метод нахождения расстояния Дамерау---Левенштейна с использованием матрицы]
    size_t Matrix::findMatrixDistDamerau(const std::wstring& st1, const std::wstring& st2)
    {
        int n = st1.size() + 1;
        int m = st2.size() + 1;
        if (n > _n || m > _m)
            assert(0);
        _table[0][0] = 0;
        for (int i = 1; i < n; i++)
            _table[i][0] = i;
        for (int j = 1; j < m; j++)
            _table[0][j] = j;
        for (int i = 1; i < n; i++)
        {
            for (int j = 1; j < m; j++)
            {
    
                _table[i][j] = std::min(_table[i][j - 1] + 1, _table[i - 1][j] + 1);
                int extraStep = 0;
                if (st1[i - 1] != st2[j - 1])
                    extraStep++;
    
                _table[i][j] = std::min(_table[i][j], _table[i - 1][j - 1] + extraStep);
                if (i > 1 && j > 1)
                {
                    if (st1[i - 1] == st2[j - 2] && st1[i - 2] == st2[j - 1])
                        _table[i][j] = std::min(_table[i][j], _table[i - 2][j - 2] + 1);
                }
            }
        }
        return _table[n - 1][m - 1];
    }
\end{lstlisting}

\begin{lstlisting}[label=lst:damer_rec,caption=Функция нахождения расстояния Дамерау---Левенштейна с использованием рекурсии]
    size_t RecurseDistDamerau(const std::wstring& st1, const std::wstring& st2, int size1, int size2)
    {
        if (size1 == 0)
            return size2;
        if (size2 == 0)
            return size1;
    
        size_t extraStep = 0;
        if (st1[size1 - 1] != st2[size2 - 1])
            extraStep++;
    
        size_t cutLeft = RecurseDistDamerau(st1, st2, size1 - 1, size2) + 1;
        size_t cutRight = RecurseDistDamerau(st1, st2, size1, size2 - 1) + 1;
        size_t cutBoth = RecurseDistDamerau(st1, st2, size1 - 1, size2 - 1) + extraStep;
        size_t DamerauCut = cutBoth + 1;
        if (size1 > 1 && size2 > 1 && st1[size1 - 1] == st2[size2 - 2]
            && st1[size1 - 2] == st2[size2 - 1])
            DamerauCut = RecurseDistDamerau(st1, st2, size1 - 2, size2 - 2) + 1;
    
        cutBoth = std::min(DamerauCut, cutBoth); //need static here
        size_t chosenOne = std::min(std::min(cutRight, cutLeft), cutBoth);
        return chosenOne;
    }
\end{lstlisting}

\begin{lstlisting}[label=lst:damer_rec_mem,caption=Функция нахождения расстояния Дамерау---Левенштейна с использованием рекурсии c мемоизацией]
    size_t RecurseDistMemDamerau(const std::wstring& st1,
	const std::wstring& st2,
	int lastIndex1,
	int lastIndex2,
	Matrix& mat)
    {
        //std::cout<< "i " << "j " << lastIndex1 << " " << lastIndex2 << std::endl;
        if (mat._table[lastIndex1][lastIndex2] != INF)
            return mat._table[lastIndex1][lastIndex2];

        if (lastIndex1 == 0)
        {
            mat._table[lastIndex1][lastIndex2] = lastIndex2;
            return lastIndex2;
        }
        if (lastIndex2 == 0)
        {
            mat._table[lastIndex1][lastIndex2] = lastIndex1;
            return lastIndex1;
        }



        int extraStep = 0;
        if (st1[lastIndex1 - 1] != st2[lastIndex2 - 1])
            extraStep++;

        int cutLeft = RecurseDistMemDamerau(st1, st2, lastIndex1 - 1, lastIndex2,mat) + 1;
        int cutRight = RecurseDistMemDamerau(st1, st2, lastIndex1, lastIndex2 - 1,mat) + 1;
        int cutBoth = RecurseDistMemDamerau(st1, st2, lastIndex1 - 1, lastIndex2 - 1,mat) + extraStep;
        int DamerauCut = cutBoth + 1;
        if (lastIndex1 > 1 && lastIndex2 > 1 && st1[lastIndex1 - 2] == st2[lastIndex2 - 1]
            && st1[lastIndex1 - 1] == st2[lastIndex2 - 2])
            DamerauCut = RecurseDistMemDamerau(st1, st2, lastIndex1 - 2, lastIndex2 - 2,mat) + 1;
        cutBoth = std::min(DamerauCut, cutBoth);
        int chosenOne = std::min(std::min(cutRight, cutLeft), cutBoth);
        mat._table[lastIndex1][lastIndex2] = chosenOne;
        return chosenOne;
    }
\end{lstlisting}

\begin{lstlisting}[label=lst:damer_rec_mem_meth, caption=Метод нахождения расстояния Дамерау---Левенштейна с использованием функции \ref{lst:damer_rec_mem}]
    const int INF = 1e8;
    size_t Matrix::findRecurseDistMemDamerau(const std::wstring& st1, const std::wstring& st2)
    {
        for (int i = 0; i < _n; i++)
            for (int j = 0; j < _m; j++)
                _table[i][j] = INF;
        
        return RecurseDistMemDamerau(st1, st2, st1.size(), st2.size(), *this);
    }
\end{lstlisting}

\begin{lstlisting}[label=lst:damer_rec_meth, caption=Метод нахождения расстояния Дамерау---Левенштейна с использованием функции \ref{lst:damer_rec}]
size_t Matrix::findRecurseDistDamerau(const std::wstring& st1, const std::wstring& st2)
{
	return RecurseDistDamerau(st1, st2, st1.size(), st2.size());
}
\end{lstlisting}


\chapter*{\hfill \centering ПРИЛОЖЕНИЕ Б\hfill}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ Б}
Приведена реализация тестов для разработанного ПО.
\begin{lstlisting}[label=lst:unit_tests, caption=Модульные тесты]
    //
    // Created by Андрей on 10/09/2023.
    //
    #include <gtest/gtest.h>
    #include "../../src/table.hpp"
    
    //Тестирование при словах одинаковой длины
    TEST(LenTest, EQLENTEST) {
        std::wstring st1 = L"wwwwwwc";
        std::wstring st2 = L"bbbbbbc";
        Matrix mat(st1.size(),st2.size());
        
        int DamerauLen = 6;
        int LevLen  = 6;
        
        int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
        int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
        int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
        
        int lenMatLev = mat.findMatrixDistLev(st1,st2);
        
        ASSERT_EQ(DamerauLen,lenMatDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
        ASSERT_EQ(LevLen,lenMatLev);
    }
    
    //Тестирование с различными результатами при использовании различных расстояний
    TEST(LenTest, DIFLENTEST) {
        std::wstring st1 = L"AB";
        std::wstring st2 = L"BA";
        Matrix mat(st1.size(),st2.size());
        
        int DamerauLen = 1;
        int LevLen  = 2;
        
        int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
        int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
        int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
        
        int lenMatLev = mat.findMatrixDistLev(st1,st2);
        
        ASSERT_EQ(DamerauLen,lenMatDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
        ASSERT_EQ(LevLen,lenMatLev);
    }
    
    
    //Различающийся результат расстояний при словах различной длины
    TEST(LenTest, LongWords) {
        std::wstring st1 = L"KAABKA";
        std::wstring st2 = L"AKAAK";
        Matrix mat(st1.size(),st2.size());
        
        int DamerauLen = 3;
        int LevLen  = 3;
        
        int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
        int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
        int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
        
        int lenMatLev = mat.findMatrixDistLev(st1,st2);
        
        ASSERT_EQ(DamerauLen,lenMatDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
        ASSERT_EQ(LevLen,lenMatLev);
    }
    
    //Тестирование подобное тесту на русском языке
    TEST(LenTest, English) {
        std::wstring st1 = L"BCA";
        std::wstring st2 = L"ABC";
        Matrix mat(st1.size(),st2.size());
        
        int DamerauLen = 2;
        int LevLen  = 2;
        
        int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
        int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
        int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
        
        int lenMatLev = mat.findMatrixDistLev(st1,st2);
        
        ASSERT_EQ(DamerauLen,lenMatDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
        ASSERT_EQ(LevLen,lenMatLev);
    }
    
    //Использование русских букв
    TEST(LenTest, Russian) {
        std::wstring st1 = L"ВФА";
        std::wstring st2 = L"АВФ";
        Matrix mat(st1.size(),st2.size());
        
        int DamerauLen = 2;
        int LevLen  = 2;
        
        int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
        int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
        int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
        
        int lenMatLev = mat.findMatrixDistLev(st1,st2);
        
        ASSERT_EQ(DamerauLen,lenMatDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
        ASSERT_EQ(LevLen,lenMatLev);
    }
    
    //Большая разница в длине слов
    TEST(LenTest, BIGSIZEDIFF) {
        std::wstring st1 = L"ADF";
        std::wstring st2 = L"ABFDSADADF";
        Matrix mat(st1.size(),st2.size());
        
        int DamerauLen = 7;
        int LevLen  = 7;
        
        int lenMatDamerau =  mat.findMatrixDistDamerau(st1, st2);
        int lenRecurseMemDamerau = mat.findRecurseDistMemDamerau(st1, st2);
        int lenRecurseDamerau =  mat.findRecurseDistDamerau(st1, st2);
        
        int lenMatLev = mat.findMatrixDistLev(st1,st2);
        
        ASSERT_EQ(DamerauLen,lenMatDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseDamerau);
        ASSERT_EQ(DamerauLen,lenRecurseMemDamerau);
        ASSERT_EQ(LevLen,lenMatLev);
    }
 \end{lstlisting}
 
 
 
 
 
 
 
 